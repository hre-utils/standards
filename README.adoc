= Standards & Guiding Principals
:toc: left
:toclevels: 3
:source-highlighter:     pygments
:pygments-style:         algol_nu
:pygments-linenums-mode: table

The principals by which HRE Utils shall all adhere, and the prerequisite boilerplate for such utilities.

== Principals
=== Make it functional
It must serve a clear and defined purpose.
It must effectively solve the problem set forth.
Above all else, it must work.

=== Make it interesting
There may be an easier way to do something.
There may be a better suited tool or language for the problem at hand.
But implementing '`solved`' code is uninteresting.
Why use Python's `import argparse` when you can write your own Bash argument parser.
This is a project of exploration, learning, and bending the rules a bit.

=== Make it right
Just because we're approaching things in a potentially silly way, there's no reason to not do them _right_.
Do a good job, don't cut corners.
"`Good enough`" isn't.


== Standards
=== Paths
Respect user's paths if set: `$XDG_CONFIG_HOME`, `$XDG_DATA_HOME`.

.Config directory
[source,bash]
----
"${XDG_CONFIG_HOME:-$HOME/.config}/hre-utils/$PROJECT/"
----

.Data directory
[source,bash]
----
"${XDG_DATA_HOME:-$HOME/.local/share}/hre-utils/$PROJECT/"
----

=== Dependencies
All '`library`' files should follow a standard naming convention:

.Filename requirements
. Contain only lower-case letters, dashes, and a '`.sh`' extension
. Parts separated by '-'
. Begin with `hre-lib-`

Example: `hre-lib-colors.sh`.

.Execution requirements
. Contains no executable code
. Setup logic is in an `\\__init__` function
. Teardown should be placed into a link:#_name_uniqueness[uniquely prefixed] function, the name of which is appended to a global array `TEARDOWN`

A `trap EXIT` will run each function in `${TEARDOWN[@]}`.
The `\\__init__` function is run when imported.

.Additional requirements
. Implement a unique named variable to prevent duplicate imports

== Style Guide
=== Indentation
Spaces, not tabs.

4 is too many, 2 is too few. 3 is correct.

=== Text wrap
Whenever possible, text should wrap at 80 characters.

_Not_ for compatibility with archaic systems or standards, but because it provides a solid benchmark for a medium-narrow width terminal.
If a line begins to exceed 80 columns, ask why.
Can it be better written on more lines for clarity?
Can it be broken up using an array to pass the parameters?
More often than not, the answer is "`yes`".

=== Variable names
Variables should be descriptive, and consistently styled to indicate as to their scope.

[cols='1,1,3']
|===
| Example | Scope | Description

| `$local`
| Local
| All lower case, used within functions or in-line script

| `$GLOBAL`
| Global
| All caps, do not collide with Bash https://tldp.org/LDP/abs/html/internalvariables.html[global variables]

| `$\\__parameter__`
| Global
| Parameters set by CLI flags, double-underscore, all lower

| `$_intermediate`
| Local
| Used as an intermediate calculation before the final value

| `${self[key]}`
| File local (kinda)
| File unique map holding key:value pairs
|===

=== Function names
Powershell did very few things right, though their 'Verb-Noun' naming convention is among them.
It allows for self-documenting function names, reducing the amount to which functions must be looked up to determine what they do.
A function's name should make the usage self-evident.

What do you think `generate_unique_id()` does?
What does it return?

How about `arrgg()`?

The exception is when introducing functions to be sourced by other scripts.
They are given simple, straightforward names prefixed with a period.
Example: `.import`.
It is then clear when calling them that it's a sourced '`method`'.

== Boilerplate
=== Argument parsing

.getopts-esque
[source,bash]
----
# Defaults & boolean:
__alpha__=false

while [[ "$#" -gt 0 ]] ; do
   case "$1" in
      -h|--help)
            usage 0 ;;

      # Switch:
      -a|--alpha)
            __alpha__=true ;;

      # Param:
      -b|--bravo)
            shift ; __bravo__="$1" ; shift ;;

      -[^-]*)
            opts=( $(sed -E -e 's,^-,,' -e 's,(.),-\1\n,g' <<< "$1") )
            shift

            # If there's only 1 opt, and it hasn't already been covered by those
            # above, it's __unsupported__. Shift it off and continue.
            [[ ${#opts[@]} -eq 1 ]] && {
               __unsupported__+=( ${opts[0]} )
               continue
            }

            set -- ${opts[@]} $@ ;;

      --) shift ; break ;;

      --*) __unsupported__+=( "$1" ) ; shift ;;

      *) __positional__+=( "$1" ) ; shift ;;
   esac
done
----

.last opt
[source,bash]
----
local lopt
declare -a __alpha__ __bravo__

while [[ $# -gt 0 ]] ; do
   case $1 in
      -a|--alpha)
            shift ; lopt=__alpha__ ;;

      -b|--bravo)
            shift ; lopt=__bravo__ ;;

      *)    # Default if no opt yet passed:
            if [[ -z $lopt ]] ; then
               __alpha__+=( $1 )
            else
               declare -n arr=$lopt
               arr+=( $1 )
            fi

            shift ;;
   esac
done
----

=== Debugging & print statements
The user should only see text that is necessary.
Either to their immediate decision making, altering the execution of the script, or errors & warnings.

Output levels should be set in a configuration file, depending on user perferences.
Log levels and output are defined as follows:

[source,bash]
----
function write {
   local lvl=$1 text="$2"

   local debug_level=${__debug_level__:-$debug_level}
   read low high __ <<< ${debug_level//,/ }
   low=${low:-1} ; high=${high:-3}

   [[ $lvl -lt $low  ]] && return 0
   [[ $lvl -gt $high ]] && return 0

   local lvlname color
   case $lvl in
     -2) color="${bk}"  ; lvlname='TRASH' ;;
     -1) color="${bk}"  ; lvlname='NOISE' ;;
      0) color="${cy}"  ; lvlname='DEBUG' ;;
      1) color="${wh}"  ; lvlname='INFO'  ;;    # <- default user-visible from
      2) color="${yl}"  ; lvlname='WARN'  ;;    #    here down
      3) color="${brd}" ; lvlname='CRIT'  ;;

      *) color="${wh}"  ; lvlname='INFO'  ;;
   esac

   echo "${color}[$lvlname] ${text}${rst}"
}
----

Always tend towards sparse & concise output.

=== Error handling
> Errors should never pass silently. +
> Unless explicitly silenced.
> -- The Zen of Python

All errors should be handled and tracked appropriately.
Only exit when execution _cannot_ continue.

When parsing a config file I too often see programs exit on the first error found.
Don't.
Parse and collect all errors & warnings.
Present a summation.
Don't punish the user for your own lack of foresight, design, and implementation.

.argparse example
[source,bash]
----
# Handle CLI arguments:
while [[ $# -gt 0 ]] ; do
   case $1 in
      -h|--help)
            usage 0 ;;

      -a|--alpha)
            __alpha__=true ; shift ;;

      -*)   # Invalid args:
            __invalid__="$1" ; shift ;;

      *)   # Positional:
            __positional__+=( "$1" ) ; shift ;;
   esac
done

# Create array to hold error output:
declare -a VALIDATION_ERRORS

if [[ ${#__invalid__[@]} -gt 0 ]] ; then
   VALIDATION_ERRORS+=(
      "Invalid options: ${__invalid__[@]}"
   )
fi

if [[ ${#__positional__[@]} -ne 1 ]] ; then
   VALIDATION_ERRORS+=(
      "Received ${#__positional__[@]} positional args, expected 1"
   )
fi

# If output array has values, print to user & exit:
if [[ ${#VALIDATION_ERRORS[@]} -gt 0 ]] ; then
   for idx in "${!VALIDATION_ERRORS[@]}" ; do
      echo "$((idx+1)). ${VALIDATION_ERRORS[$idx]}"
   done
   exit 1
fi
----

This handles all classifications of errors as effectively interchangable.
We can easily handle them individually within their respective `if` statements.
Maybe in the above case, we don't need to `exit` if an additional invalid positional parameter was passed.
Perhaps ``warn``ing the user, stripping the param, and continuing is sufficient.

=== Imports
Must sequentially check:

. _./lib/$file_
. `$(which $file)`

Providing a relative _lib/_ dir allows the user to potentially override (or extend) functionality.

.Sourcing with https://github.com/hre-utils/import[.import]
[source,bash]
----
source $(which hre-lib-source.sh)
.import hre-lib-conf.sh --optional hre-lib-colors.sh
----

.Manual sourcing
[source,bash]
----
dependencies=( hre-lib-colors.sh  hre-lib-conf.sh )
dep_not_met=()

for dep in "${dependencies[@]}" ; do
   #───────────────────────────( already sourced )──────────────────────────────
   # If we've already sourced this dependency, its respective __sourced_XX var
   # will be set. Don't re-source.
   _dep="${dep%.*}"
   dep_sourcename="__source_${_dep//[^[:alnum:]_]/_}__"
   [[ -n "${!dep_sourcename}" ]] && continue

   #─────────────────────────────( try source )─────────────────────────────────
   if [[ -e "${LIBDIR}/${dep}" ]] ; then
      source "${LIBDIR}/${dep}"
   elif [[ $(which ${dep} 2>/dev/null) ]] ; then
      source "$(which ${dep})"
   else
      dep_not_met+=( "$dep" )
   fi
done

if [[ ${#dep_not_met} -gt 0 ]] ; then
   echo "Failed to source: [${dep_not_met[@]}]"
   exit 1
fi
----


=== Name Uniqueness
Bash does not have file scoped variables, only local/global.
As heavy use of ``import``s is made, we cannot guarantee one file's variables aren't stomped on by another.

Wherever possible, '`library`' code should contain exclusively local variables.
When not possible, they should be stored as key:value pairs in a uniquely (yet reproducibly) named dictionary.
There are two possible methods that have been used for a reasonable assurance of uniqueness across currently sourced files:

.Transformed
[source,bash]
----
function __init__ {
   # ...

   # Grab file name from full path, strip suffix
   local name=$( basename "${BASH_SOURCE[0]%.*}" )

   # Replace anything that isn't a bash 'word' character [_a-zA-Z0-9] with '_',
   # then ensure 1st character is not a digit:
   name=${file//[^[:alnum:]_]/_}
   name=${file/[[:digit:]]/_}

   declare -Ag $name

   # ...
}
----

.Hashed
[source,bash]
----
function __init__ {
   # ...

   # md5 the full file path, ensuring 1st character is not a digit:
   declare -Ag $(
      md5sum "${BASH_SOURCE[0]}" | awk 'sub(/^[[:digit:]]/, "_") {print $1}'
   )

   # ...
}
----

The latter approach has fewer steps, but requires both `md5sum` and `gawk`.
